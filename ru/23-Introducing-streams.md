Введение в потоки данных
===================

Сложность: средняя

Алекс Керр


Мы уже охватили некоторые основы, и теперь вы м
ожете найти сходства между C++ и С. С этого номера 
мы будем искать различия между С++ и С. Прочитайте 
The C Cave, если хотите узнать об основах: об 
операторе if и циклах.


Совместимость с С
--------------------
Некоторые стандартные заголовочные файлы библиотек 
С доступны и в С++. Чтобы их использовать, «включите» 
(include) их обычным способом, но добавьте «c» перед 
названием и уберите «.h». Например, код в С:

    #include <stdlib. h>
    #include <stdio. h>

Становится таким в С++:

    #include <cstdlib>
    #include <cstdio>

Это даст вам доступ ко всем функциям внутри этих 
библиотек, таким как printf() и rand(), что помогает 
С++ использовать полезные функции из С.


Потоки данных ввода/вывода
------------
Однако сходится не все, как вы могли заметить. 
Например, когда мы выводили данные, мы использовали 
cout вместо printf(). Это происходит из-за того, 
что в С++ используются потоки данных I/O (сокращение 
от Input/Output – ввод/вывод).

Это означает то, что не функции управляют вводом и 
выводом, а обычные объекты. Объекты и классы мы 
разберем позднее, так как это существенная разница 
между С и С++.

Существуют три основных заголовка для потока I/O: 
<iostream> отвечает за ввод и вывод в консоли, 
<fstream> используется для файлов, а <sstream> – 
для строк.

Мы уже знаем, как работает <iostream>, так что давайте 
посмотрим на <fstream>.


Чтение и создание файлов
-------------------------
    #include <iostream>
    #include <fstream>
    #include <string>
    using namespace std;
    int main()
    {
    // Создайте вводный файловый поток «reader»:
    ifstream reader(“test.txt”);
    while(reader.good())
    {
        string temp;
        getline(reader, temp);
        cout << temp << endl;
    }
    reader.close();
    return 0;
    }

Этот код позволяет прочитать файл «test.txt» (в той 
же директории, в которой находится исполняемый модуль) 
и выводит его содержимое. Вы можете использовать 
символ «>>», как мы делаем это с cin, но вы обнаружите, 
что текст будет прочтен только до пробела.

У вас может возникнуть эта проблема и с cin, поэтому 
если вы хотите получить название с пробелами, вы можете 
сделать так:

  ```getline(cin, variable);```

Введенная информация будет полностью прочитана и 
сохранена в переменную типа string.

Для вывода используем:

  #include <iostream>
  #include <fstream>
  #include <string>
  using namespace std;
  int main()
  {
    // Выводит файловый поток «writer»:
    ofstream writer(“test. txt”);
    // Допишите текст к файлу:
    writer << “Hello” << endl;
    writer << “This is a test file” << endl;
    writer.close();
    return 0;
  }

Эта программа создаст файл «test.txt» с обработанным 
текстом в той же директории, в которой находится 
исполняемый модуль. Однако все файлы в ней будут 
заменены, так что будьте осторожнее!

Чтобы избежать этого и сделать кое-что поинтереснее, 
есть разные опции для создания объектов строчного 
файла:

    +-------------+------------------------------+--------------------------------+
    |   Опция     |         Описание             |             Примечания         |
    +-------------+------------------------------+--------------------------------+
    | ios::app    | Добавляется к существующему  |                                |
    |             | файлу, не заменяя его.       |                                |
    | ios::in     | Получает вводные данные из   | По умолчанию, если             |
    |             | файла.                       | используется ifstream(filename)|
    | ios::out    | Выводит данные в файл.       | По умолчанию, если             |
    |             |                              | используется ofstream(filename)|
    | ios::binary | Читает файл, не как текст,   |                                |
    |             | а как двоичный код.          |                                |
    +-------------+------------------------------+--------------------------------+

Можно добавить следующие опции, если вы сначала создаете поток:

    // Создайте поток, который может вводить и выводить данные:
    fstream(filename, ios::in, ios::out);
    // Создайте поток, который будет присоединен к файлу:
    ofstream(filename, ios::app);

Когда поток создан, он связывается с буфером памяти. 
Когда информация вставляется в поток или выходит из 
него, она точно так же вставляется в буфер или выходит 
из него. Это означает то, что если файл вывода 
используется, но он не закрыт, то часть данных может 
не попасть в файл вывода. Когда файл закрыт, любая 
информация в связанном буфере, будет удалена. Пока 
закрытая функция fstream удаляет поток, могут быть 
значительные потери данных.

Потоки в С++ по определению являются «безопасными для
типа данных», так как они могут прочитать вводное 
значение, не используя сам тип. В языке С такое 
невозможно, поэтому обязательно прожектируйте функции 
sscanf.

В следующий раз мы рассмотрим строки и <sstream>, что 
поможет вам конвертировать строки в другие типы данных. 
Надеюсь, вы теперь понимаете, насколько похожи все 
потоки, но при этом каждый предназначен для разных целей. 
Попробуйте вводить и выводить данные из файлов и посмотрите, 
что вы можете сделать.
