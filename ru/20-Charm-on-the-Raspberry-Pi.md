Введение в CHARM

Charm на Raspberry Pi
=====================

Peter Nowosad, Guest Writer

Уровень сложности: Продвинутый

Эта и последующие статьи призваны разжечь интерес и дать понимание языка Charm для Raspberry Pi. Как создатель этого языка мне интересно донести его до младшего поколения пользователей Raspberry Pi, а также для людей, стремящихся узнать немного больше о таинственном мире программирования.

Инструментарий Charm нетребователен к ресурсам, но в то же время ое достаточно мощный и предоставляет гибкую среду разработки. Приложения любой сложности можно разрабатывать маленькими частями, код компилируется быстро, например, весь пакет Charm можно пересобрать менее чем за минуту!

Сейчас мне бы хотелось рассказать о некоторых частных моментах использования Charm. Я надеюсь, что это поможет людям начать разработку на Charm и присоединиться к сообществу более чем 1200 программистов со всего мира, которые уже посетили веб-сайт Charm.


Установка
---------
Charm версии 2.6.1 уже поставляется в выпуске Risc OS RC6 для Raspberry Pi и находится в каталоге Programming. Тем не менее, я бы рекомендовал вам обновиться до последней версии (на момент написания статьи это 2.6.4), которая распространяется свободно по условиям лицензии Gnu Public License в виде простого файла zip через сайт charm.qu-bit.co.uk. На этом сайте вы можете узнать больше о языке, а также связаться со мной через форум Charm, посмотреть скриншоты различных демонстрационных программ на Charm, самая интересная из которых Decapedees, стрелялка похожая на Pacman с приятной графикой и музыкой.

Вам также могут прийтись по душе векторные операции с плавающей точкой (VFP, vector floating point) ARM11, которые выключены по-умолчанию для тех, кто запускает Charm на эмуляторах и ранних версиях процессоров ARM. Вам нужно будет включить VFP в оболочке Charm и пересобрать дистрибутив, инструкции можно найти на сайте. После этого, вы получите, например, на порядок более высокую производительность в программе Mandelbrot explorer, т.к. эмулятор вычислений с плавающей точкой (FPE, floating point emulator) будет заменён родными инструкциями VFP сопроцессора.


Инструментарий
--------------
Набор инстурментов Charm для Risc OS содержит следующие основные приложения:

* **!Charm** - Оболочка для выполнения инструментария. Поддерживает перетаскивание мышью для файлов и папок, журналирование команд и отчёты об ошибках.
* **edit** - Редактор общего назначения, используется для написания и разработки кода Charm (перетащите файлы или папки, которые нужно редактировать, на иконку Charm с нажатой клавишей Shift)
* **armc** - Компилятор, создающий объектный файл в бинарном формате из исходного кода на языке Charm.
* **arma** - Ассемблер, создающий объектный файл в бинарном формате из исходного кода на языке ARMassembly.
* **arml** - Линковщик, собирающий объектные файлы Charm в исполнимый файл Risc OS или модуль.


Новые проекты
-------------
Создание новых проектов по шаблону в Charm делается просто с помощью утилиты !NewProject. Просто выберите New Project из меню, укажите имя по желанию (или оставьте начальное, MyProject) и перетащите значок папки в каталог, где нужно разместить проект. Потом вы можете скомпилировать проект перетаскиванием значка папки на иконку Charm, при этом в журнале Charm вы должны увидеть примерно следующее:

Необходимые каталоги проекта создаются автоматически, а именно:

* **src** - исходные файлы Charm
* **obj** - объектные файлы, созданные компиляторои или ассемблером

Если вы не хотите вставлять фрагменты ассемблера ARM в исходне коды на Charm, можете создать отдельный каталог:

* **arm** - исходные файлы ассемблера ARM

Программы, находящиеся в каталоге приложений, обычно привязываются к правильному путю !RunImage с помощью файла 'build с использованием команды `program`.


Модульное программирование
--------------------------
Концепция модулей - ключевой момент к пониманию Charm (важно: в этом контексте модули Charm и модули Risc OS - не одно и то же!). Каждый модуль объявляется ключевым словом `module`, и каждый исходный файл модуля Charm определяет только один модуль. Тем не менее, в своей программе можно использовать (импортировать) любое количесвто модулей.

Обычно модули относятся к составным частям проекта или модулям библиотеки времени выполнения (RTL, runtime library), которые предоставляют основные функции, такие как управление окнами, файлами, клавиатурой и экраном. Документацию на них можно найти на веб-сайте Charm. Порядок компиляции модулей определяется файлом 'build, в котором также указывается имя и расположение связаннго приложения или других модулей.


Начало работы
-------------
Итак, пришло время познакомиться с кодом  Charm. Каждый проект должен содержать один и только один модуль, в котором экспортирована процедура ~start с одной из двух возможных сигнатур.

Если обработка аргументов командной строки не требуется, процедура ~start будет определяться так:

    module Main
    {
      export proc ~start() {...startup code }
    }

Таким образом, классическое приложение "Hello, World" на Charm, использующая поток vdu библиотеки времени выполнения Out, может быть закодирована в файле `src.hello`:

    import lib.Out;
    module Hello {
      export proc ~start () {
        Out.vdu.str ("Hello World!\n");
      }
    }

При этом, чтобы программу можно было запустить, файл сборки проекта должен содержать:

    module hello
    program hello

Библиотеку Out линковщик подключит автоматически.


Практическая задача
-------------------
Если вы готовы к новому испытанию, я предлагаю заменить модуль по-умолчанию `!NewProject myProject` на следующий код, выводящий первую дюжину факториальных чисел:

    import lib.Out;
    module MyProject
    {
      proc factorial (int n) int
      {
        if n <= 1 return 1;
        return n * factorial (n - 1);
      }
      export proc start (ref array ref array char argv)
      {
      for int i := 1 step inc (i) while i <= 12
        Out.vdu.num_fld (i, 2).str ("! = ").num(factorial (i )).nl ();
      }
    }

Этот код показывает пример использования рекурсии для вычисления каждого нового значения через умножение, учитывая аксиому `1! = 1`.

Наконец, как упражнение, попробуйте изменить программу так, чтобы она вычисляла первые 20 чисел без ограничений на значение числа в 32-битном представлении (подсказка: возвращайте вещественное число из `factorial` и используйте `.float` вместо `.num` для его вывода).


Что дальше?
-----------
В следующий раз я расскажу про типы данных Charm, переменные, строки и области видимости.
